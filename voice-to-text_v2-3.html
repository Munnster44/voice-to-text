<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Voice Notes V2T ‚Äî v2.3</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0b1220">

<style>
  body{margin:0;font-family:system-ui;background:#0b1220;color:#e8eefc}
  header{
    padding:14px;font-weight:700;border-bottom:1px solid #223;
    display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;
  }
  #recStatus{color:#ff5c5c;font-weight:800;display:none;animation:pulse 1.2s infinite}
  @keyframes pulse{0%{opacity:1}50%{opacity:.3}100%{opacity:1}}
  main{padding:14px;max-width:920px;margin:auto}
  .card{background:#111b2e;border-radius:14px;padding:14px;margin-bottom:14px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button,input,select{border-radius:10px;border:none;padding:10px;font-size:14px}
  button{background:#2a355a;color:#fff;font-weight:650;cursor:pointer}
  button.active{background:#4ea1ff;color:#041428}
  button.recording{background:#39d98a;color:#042}
  button.danger{background:#ff5c5c;color:#300}
  input,select{background:#0d1730;color:#fff}
  textarea{
    width:100%;min-height:340px;border-radius:12px;background:#0d1730;color:#fff;
    padding:12px;border:none;line-height:1.4
  }
  small{color:#9fb1d6}
  .stats{display:flex;gap:14px;flex-wrap:wrap}
  .chip{display:inline-flex;gap:8px;align-items:center;background:#0d1730;border-radius:999px;padding:8px 10px}
  .muted{color:#9fb1d6;font-size:12px}
  .statusline{font-size:12px;color:#9fb1d6;min-height:16px}
  label.toggle{cursor:pointer;user-select:none}
  label.toggle input{transform:scale(1.2);margin-right:8px}
</style>
</head>

<body>
<header>
  <div>üé§ Voice Notes ‚Äî V2T <span class="muted">v2.3 (AutoSave)</span></div>
  <div class="row" style="justify-content:flex-end">
    <span id="recStatus">‚óè RECORDING</span>
  </div>
</header>

<main>

<!-- SPEAKERS -->
<div class="card">
  <small>Speakers (tap to select)</small>
  <div class="row" id="speakerButtons" style="margin-top:8px"></div>

  <div class="row" style="margin-top:10px">
    <input id="newName" placeholder="Add speaker name (e.g., Glen, Liz, Chair)">
    <button onclick="addSpeaker()">Add</button>
    <button class="danger" onclick="resetSaved()">Reset Saved Data</button>
  </div>

  <div class="muted" style="margin-top:8px">
    Tip: Speaker names + transcript are saved automatically on this device.
  </div>
</div>

<!-- CONTROLS -->
<div class="card">
  <div class="row">
    <button id="startBtn" onclick="start()">Start</button>
    <button class="danger" onclick="stop()">Stop</button>
    <button onclick="insertLabel()">Insert Speaker</button>
    <button onclick="saveText()">Save .txt</button>
    <button onclick="clearText()">Clear</button>
  </div>

  <div class="row" style="margin-top:10px">
    <select id="lang" title="Recognition language">
      <option value="en-CA">English (Canada)</option>
      <option value="fr-CA">Fran√ßais (Canada)</option>
      <option value="en-US">English (US)</option>
      <option value="en-GB">English (UK)</option>
      <option value="fr-FR">Fran√ßais (France)</option>
    </select>

    <span class="chip">
      <label class="toggle">
        <input id="autoRestartToggle" type="checkbox" checked>
        Auto-Restart
      </label>
    </span>

    <span class="chip">
      <span class="muted">Status:</span>
      <span id="statusMsg" class="statusline">Idle</span>
    </span>
  </div>
</div>

<!-- TRANSCRIPT -->
<div class="card">
  <textarea id="out" placeholder="Transcript‚Ä¶"></textarea>
  <div class="muted" style="margin-top:8px">
    Auto-Restart helps when the browser ends after silence. If the screen locks, you may need to press Start again.
  </div>
</div>

<!-- STATS -->
<div class="card stats">
  <small>üïí Time: <span id="timer">00:00</span></small>
  <small>üìù Words: <span id="words">0</span></small>
</div>

<small>‚úî Installable PWA ‚Ä¢ ‚úî Speaker-labelled ‚Ä¢ ‚úî Timestamped ‚Ä¢ ‚úî Watchdog restart ‚Ä¢ ‚úî AutoSave</small>

</main>

<script>
/* PWA */
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("service-worker.js");
}

/* Speech Recognition */
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;

let rec = null;
let running = false;

let userStopped = false;      // if true, don't auto-restart
let isStarting = false;       // prevent double starts
let lastEndWasAuto = false;   // for status messaging

const STORAGE_KEY = "v2t_voice_notes_v2_3";

const out = document.getElementById("out");
const recStatus = document.getElementById("recStatus");
const startBtn = document.getElementById("startBtn");
const langSel = document.getElementById("lang");
const wordsEl = document.getElementById("words");
const timerEl = document.getElementById("timer");
const statusMsg = document.getElementById("statusMsg");
const autoRestartToggle = document.getElementById("autoRestartToggle");

/* Speakers */
let speakers = ["Speaker 1", "Speaker 2"];
let current = speakers[0];
const btns = document.getElementById("speakerButtons");

/* Timer */
let seconds = 0;
let timerInt = null;

/* ---------- AutoSave ---------- */
function saveState() {
  try {
    const state = {
      speakers,
      current,
      transcript: out.value,
      lang: langSel.value,
      autoRestart: autoRestartToggle.checked
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (e) {}
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;

    const state = JSON.parse(raw);

    if (Array.isArray(state.speakers) && state.speakers.length) {
      speakers = state.speakers.slice(0, 30).map(String);
    }
    if (typeof state.current === "string" && speakers.includes(state.current)) {
      current = state.current;
    } else {
      current = speakers[0] || "Speaker 1";
    }

    if (typeof state.transcript === "string") out.value = state.transcript;
    if (typeof state.lang === "string") langSel.value = state.lang;
    if (typeof state.autoRestart === "boolean") autoRestartToggle.checked = state.autoRestart;
  } catch (e) {}
}

function resetSaved() {
  if (!confirm("Reset saved speakers + transcript on this device?")) return;
  localStorage.removeItem(STORAGE_KEY);

  speakers = ["Speaker 1", "Speaker 2"];
  current = speakers[0];
  out.value = "";
  langSel.value = "en-CA";
  autoRestartToggle.checked = true;

  seconds = 0;
  timerEl.textContent = "00:00";

  renderSpeakers();
  updateStats();
  setStatus("Reset complete");
}
/* -------------------------------- */

function setStatus(text) {
  statusMsg.textContent = text;
}

function renderSpeakers() {
  btns.innerHTML = "";
  speakers.forEach(s => {
    const b = document.createElement("button");
    b.textContent = s;
    if (s === current) b.classList.add("active");
    b.onclick = () => { current = s; renderSpeakers(); saveState(); };
    btns.appendChild(b);
  });
}

function addSpeaker() {
  const v = document.getElementById("newName").value.trim();
  if (!v) return;
  speakers.push(v);
  current = v;
  document.getElementById("newName").value = "";
  renderSpeakers();
  saveState();
}

function timestamp() {
  return new Date().toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });
}

function beep(freq, dur) {
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    osc.frequency.value = freq;
    osc.connect(ctx.destination);
    osc.start();
    setTimeout(() => { osc.stop(); ctx.close(); }, dur);
  } catch (e) {}
}

function startTimer() {
  stopTimer();
  seconds = 0;
  timerEl.textContent = "00:00";
  timerInt = setInterval(() => {
    seconds++;
    const m = String(Math.floor(seconds / 60)).padStart(2, "0");
    const s = String(seconds % 60).padStart(2, "0");
    timerEl.textContent = `${m}:${s}`;
  }, 1000);
}

function stopTimer() {
  if (timerInt) clearInterval(timerInt);
  timerInt = null;
}

function updateStats() {
  const words = out.value.trim().match(/\S+/g);
  wordsEl.textContent = words ? words.length : 0;
}

function insertLabel() {
  out.value += `\n[${timestamp()}] [${current}] `;
  updateStats();
  saveState();
  out.focus();
}

/* Build fresh recognition each start (most stable) */
function buildRecognition() {
  const r = new SR();
  r.lang = langSel.value;
  r.continuous = true;
  r.interimResults = false;

  r.onstart = () => {
    running = true;
    isStarting = false;
    recStatus.style.display = "inline";
    startBtn.classList.add("recording");

    setStatus(lastEndWasAuto ? "Restarted after silence" : "Listening‚Ä¶");
    startTimer();
    beep(880, 120);
  };

  r.onresult = (e) => {
    let text = "";
    for (let i = e.resultIndex; i < e.results.length; i++) {
      if (e.results[i].isFinal) text += e.results[i][0].transcript;
    }
    if (text) {
      out.value += `[${timestamp()}] [${current}] ${text.trim()}.\n`;
      updateStats();
      saveState();
    }
  };

  r.onerror = (e) => {
    running = false;
    recStatus.style.display = "none";
    startBtn.classList.remove("recording");
    stopTimer();
    isStarting = false;

    setStatus(`Error: ${e.error || "unknown"}`);

    if (!userStopped && autoRestartToggle.checked) {
      lastEndWasAuto = true;
      setTimeout(() => safeStart(true), 600);
    }
  };

  r.onend = () => {
    running = false;
    recStatus.style.display = "none";
    startBtn.classList.remove("recording");
    stopTimer();
    isStarting = false;

    if (userStopped) {
      lastEndWasAuto = false;
      setStatus("Stopped");
      return;
    }

    if (autoRestartToggle.checked) {
      lastEndWasAuto = true;
      setStatus("Ended (silence) ‚Äî restarting‚Ä¶");
      setTimeout(() => safeStart(true), 600);
    } else {
      lastEndWasAuto = false;
      setStatus("Ended (silence)");
    }
  };

  return r;
}

function safeStart(isAuto = false) {
  if (!SR) { setStatus("Speech recognition not supported (use Chrome/Edge)."); return; }
  if (isStarting) return;
  if (running && rec) return;

  isStarting = true;
  userStopped = false;

  if (rec) { try { rec.onend = null; rec.stop(); } catch(e) {} rec = null; }
  rec = buildRecognition();

  try {
    rec.start();
    if (!isAuto) lastEndWasAuto = false;
  } catch (e) {
    setStatus("Start blocked ‚Äî retrying‚Ä¶");
    setTimeout(() => {
      try { rec.start(); if (!isAuto) lastEndWasAuto = false; }
      catch (e2) { isStarting = false; setStatus("Could not start. Tap Start again."); }
    }, 350);
  }
}

function start() {
  lastEndWasAuto = false;
  safeStart(false);
}

function stop() {
  userStopped = true;
  lastEndWasAuto = false;

  if (rec) { try { rec.stop(); } catch(e) {} }
  running = false;
  isStarting = false;

  recStatus.style.display = "none";
  startBtn.classList.remove("recording");
  stopTimer();

  setStatus("Stopped");
  beep(440, 120);
}

function saveText() {
  const blob = new Blob([out.value], { type: "text/plain;charset=utf-8" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "voice-notes.txt";
  a.click();
  URL.revokeObjectURL(a.href);
}

function clearText() {
  out.value = "";
  updateStats();
  saveState();
  seconds = 0;
  timerEl.textContent = "00:00";
  setStatus("Cleared");
}

/* Persist settings changes */
langSel.addEventListener("change", () => {
  saveState();
  if (running && !userStopped) {
    setStatus("Language changed ‚Äî restarting‚Ä¶");
    lastEndWasAuto = true;
    safeStart(true);
  }
});
autoRestartToggle.addEventListener("change", () => {
  saveState();
  setStatus(autoRestartToggle.checked ? "Auto-Restart enabled" : "Auto-Restart disabled");
});

/* Auto-save transcript edits */
let saveDebounce = null;
out.addEventListener("input", () => {
  updateStats();
  clearTimeout(saveDebounce);
  saveDebounce = setTimeout(saveState, 250);
});

/* Init */
loadState();
renderSpeakers();
updateStats();
setStatus("Idle");
</script>

</body>
</html>
